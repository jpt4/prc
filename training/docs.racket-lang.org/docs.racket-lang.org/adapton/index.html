<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Adapton: Composable, Demand-Driven Incremental Computation</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Adapton:<span class="mywbr"> &nbsp;</span> Composable, Demand-<wbr></wbr>Driven Incremental Computation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._intro%29" class="tocviewlink" data-pltdoc="x">Example:<span class="mywbr"> &nbsp;</span> Fibonacci</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._forms%29" class="tocviewlink" data-pltdoc="x">Forms</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._top%29" class="tocsubseclink" data-pltdoc="x">Adapton:<span class="mywbr"> &nbsp;</span> Composable, Demand-<wbr></wbr>Driven Incremental Computation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._intro%29" class="tocsubseclink" data-pltdoc="x">Example:<span class="mywbr"> &nbsp;</span> Fibonacci</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._forms%29" class="tocsubseclink" data-pltdoc="x">Forms</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._definitions%29" class="tocsubseclink" data-pltdoc="x">Definition Forms</a></td></tr><tr><td><a href="#%28form._%28%28lib._adapton%2Fmain..rkt%29._define%2Fmemo%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">define/<span class="mywbr"> &nbsp;</span>memo</span></a></td></tr><tr><td><a href="#%28form._%28%28lib._adapton%2Fmain..rkt%29._force%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">force</span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.4</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;7.4&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }"/></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.4&quot;);">top</a></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.4&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h2 x-source-module="(lib &quot;adapton/adapton.scrbl&quot;)" x-source-pkg="Adapton" x-part-tag="&quot;top&quot;"><a name="(part._top)"></a><a name="(mod-path._adapton)"></a>Adapton: Composable, Demand-Driven Incremental Computation</h2><p>by Clayton Mentzer and Matt Hammer cmentzer at ccs dot neu dot edu</p><p>Adapton is a library for demand driven incremental computation and dynamic programming
The library provides drop-in replacement forms for defining Racket functions that memoize
their results and record their computation graphs. In addition, it provides tools
for leveraging articulation points to improve performance of algorithms on large inputs
and the tools to mutate those inputs.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._intro%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>Example: Fibonacci</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._forms%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>Forms</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._definitions%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Definition Forms</a></p></td></tr></table><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/7.4/doc/local-redirect/index.html?doc=reference&amp;rel=require.html%23%2528form._%2528%2528lib._racket%252Fprivate%252Fbase..rkt%2529._require%2529%2529&amp;version=7.4" class="RktStxLink Sq" data-pltdoc="x">require</a></span><span class="stt"> </span><a href="" class="RktModLink" data-pltdoc="x"><span class="RktSym">adapton</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/Adapton" title="Install this package using `raco pkg install Adapton`"><span class="stt">Adapton</span></a></span></td></tr></table></p><h3 x-source-module="(lib &quot;adapton/adapton.scrbl&quot;)" x-source-pkg="Adapton" x-part-tag="&quot;intro&quot;">1<tt>&nbsp;</tt><a name="(part._intro)"></a>Example: Fibonacci</h3><p>A typical example of a dynamic programming problem is computing the Fibonacci numbers,
whose simplest implementation involves a heavy amount of duplicated computation. By
simply defining the function with define/memo, previously computed answers
are cached, avoiding the duplicated computation.</p><p>calling a funciton defined with define/memo returns a node, which is a structure that
contains a thunk. Nodes are one  of the two types of articulation points in Adapton,
the other being cells. We&rsquo;ll get to Cells in a moment. Forcing a node will force the
thunk contained within that node, and also perform a number of steps to keep track of
relationships between articulation points.</p><p>each recursive call to fib will also return a node, which means we need to force that
node before we can use it. Each node created is placed into a global level hash-table
called "*memo-table*". Then, each time a node is created we can check if it exists in
memo-table already, and use its cached result.</p><p><div class="SIntrapara">Examples:</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&lt;=</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td> </td></tr></table></td></tr><tr><td><p><span class="RktOut">graphing is OFF</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">time</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktVal">35</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktOut">cpu time: 339 real time: 340 gc time: 0</span></p></td></tr><tr><td><p><span class="RktRes">14930352</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define/memo</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&lt;=</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">force</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">force</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fib</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">define/memo: undefined;</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;</span><span class="RktErr">cannot reference an identifier before its definition</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">in module: top-level</span></p></td></tr></table></blockquote></div></p><p>The other kind of articulation point in Adapton is a cell. Cells are structures that
contain a mutable box for atomic data. The difference between cells and nodes is that a
cell will never have any successors (that is, the data contained in a cell will never force
another articulation point). We use cells to contain our input data, so that when a node
forces a cell to get the atomic data out of it, that cell is flagged as a successor to that
node, and we say that the node is dependent upon that cell.</p><p>We use these dependencies to build a Directed Computation Graph (DCG), which is a model
of the control flow of the program. When the data contained within a cell is mutated, we
can determine based on the DCG which nodes have been invalidated (dirtied), and recomputing
only those nodes will correct our now invalid result.</p><p>This allows us to only re-compute a fraction of the computations that we originally
performed to achieve a new correct result. The merge-sort example in the adapton library
uses cells liberally.</p><h3 x-source-module="(lib &quot;adapton/adapton.scrbl&quot;)" x-source-pkg="Adapton" x-part-tag="&quot;forms&quot;">2<tt>&nbsp;</tt><a name="(part._forms)"></a>Forms</h3><p>Just like the function definition forms in PLT Scheme, the formals list of a memoized function
may be a single identifier, a proper list of identifiers, or an improper list of identifiers.</p><p><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">formals</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">id</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">id</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktVar">formals</span><span class="RktPn">)</span></td></tr></table></p><h4 x-source-module="(lib &quot;adapton/adapton.scrbl&quot;)" x-source-pkg="Adapton" x-part-tag="&quot;definitions&quot;">2.1<tt>&nbsp;</tt><a name="(part._definitions)"></a>Definition Forms</h4><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._adapton/main..rkt)._define/memo))"></a><span title="Provided from: adapton | Package: Adapton"><span class="RktSym"><span class="RktSymDef RktSym">define/memo</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">name</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktVar">formals</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Defines a memoized function <span class="RktVar">name</span> with formal arguments <span class="RktVar">formals</span> and function body forms <span class="RktVar">body</span><span class="stt"> </span><span class="RktMeta">...</span>.
                            Inputs are cached in a hash table and looked up with <span class="RktSym">eq?</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>syntax</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(form._((lib._adapton/main..rkt)._force))"></a><span title="Provided from: adapton | Package: Adapton"><span class="RktSym"><span class="RktSymDef RktSym">force</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">articulation-point</span><span class="RktPn">)</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Performs some amount of work to extract the value from an articulation point. Also keeps track of dependencies between articulation points
and handles memoization, and dirtying and cleaning of articulation points. NOTE: This function overrides Racket&rsquo;s built-in force function!</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;7.4&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }"/></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.4&quot;);">top</a></span><span class="navright">&nbsp;&nbsp;<span class="nonavigation">&larr; prev</span>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.4&quot;);">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>